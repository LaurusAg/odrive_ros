diff --git a/launch/odrive.launch b/launch/odrive.launch
index 1c4c1d3..a384354 100644
--- a/launch/odrive.launch
+++ b/launch/odrive.launch
@@ -12,8 +12,8 @@
     
     <node pkg="odrive_ros" type="odrive_node" name="odrive" ns="odrive" 
             output="$(arg output)" respawn="$(arg respawn)">
-        <param name="wheel_track" value="0.285"/>
-        <param name="tyre_circumference" value="0.341"/>
+        <param name="wheel_track" value="0.650"/>
+        <param name="tyre_circumference" value="0.798"/>
         
         <param name="connect_on_startup"   value="$(arg connect_on_startup)"/>
         <param name="calibrate_on_startup" value="$(arg calibrate_on_startup)"/>
diff --git a/src/odrive_ros/odrive_interface.py b/src/odrive_ros/odrive_interface.py
index 01f7468..9986c22 100755
--- a/src/odrive_ros/odrive_interface.py
+++ b/src/odrive_ros/odrive_interface.py
@@ -26,7 +26,7 @@ class ODriveFailure(Exception):
 
 class ODriveInterfaceAPI(object):
     driver = None
-    encoder_cpr = 4096
+    encoder_cpr = 2400
     right_axis = None
     left_axis = None
     connected = False
@@ -141,7 +141,8 @@ class ODriveInterfaceAPI(object):
         
         for i, axis in enumerate(self.axes):
             self.logger.info("Calibrating axis %d..." % i)
-            axis.requested_state = AXIS_STATE_FULL_CALIBRATION_SEQUENCE
+            #axis.requested_state = AXIS_STATE_FULL_CALIBRATION_SEQUENCE
+	    axis.requested_state = AXIS_STATE_ENCODER_OFFSET_CALIBRATION
             time.sleep(1)
             while axis.current_state != AXIS_STATE_IDLE:
                 time.sleep(0.1)
@@ -239,7 +240,7 @@ class ODriveInterfaceAPI(object):
 
         #self.logger.debug("Setting drive mode.")
         for axis in self.axes:
-            axis.controller.vel_setpoint = 0
+            axis.controller.input_vel = 0
             axis.requested_state = AXIS_STATE_CLOSED_LOOP_CONTROL
             axis.controller.config.control_mode = CTRL_MODE_VELOCITY_CONTROL
         
@@ -262,8 +263,8 @@ class ODriveInterfaceAPI(object):
             self.logger.error("Not connected.")
             return
         #try:
-        self.left_axis.controller.vel_setpoint = left_motor_val
-        self.right_axis.controller.vel_setpoint = -right_motor_val
+        self.left_axis.controller.input_vel = left_motor_val
+        self.right_axis.controller.input_vel = -right_motor_val
         #except (fibre.protocol.ChannelBrokenException, AttributeError) as e:
         #    raise ODriveFailure(str(e))
         
@@ -296,15 +297,15 @@ class ODriveInterfaceAPI(object):
             
     def left_vel_estimate(self):  return self.left_axis.encoder.vel_estimate   if self.left_axis  else 0 # units: encoder counts/s
     def right_vel_estimate(self): return self.right_axis.encoder.vel_estimate  if self.right_axis else 0 # neg is forward for right
-    def left_pos(self):           return self.left_axis.encoder.pos_cpr        if self.left_axis  else 0  # units: encoder counts
-    def right_pos(self):          return self.right_axis.encoder.pos_cpr       if self.right_axis else 0   # sign!
+    def left_pos(self):           return self.left_axis.encoder.pos_cpr_counts        if self.left_axis  else 0  # units: encoder counts
+    def right_pos(self):          return self.right_axis.encoder.pos_cpr_counts       if self.right_axis else 0   # sign!
     
     # TODO check these match the right motors, but it doesn't matter for now
-    def left_temperature(self):   return self.left_axis.motor.get_inverter_temp()  if self.left_axis  else 0.
-    def right_temperature(self):  return self.right_axis.motor.get_inverter_temp() if self.right_axis else 0.
+    def left_temperature(self):   return self.left_axis.motor.fet_thermistor.temperature  if self.left_axis  else 0.
+    def right_temperature(self):  return self.right_axis.motor.fet_thermistor.temperature if self.right_axis else 0.
     
-    def left_current(self):       return self.left_axis.motor.current_control.Ibus  if self.left_axis and self.left_axis.current_state > 1 else 0.
-    def right_current(self):      return self.right_axis.motor.current_control.Ibus if self.right_axis and self.right_axis.current_state > 1 else 0.
+    def left_current(self):       return self.left_axis.motor.I_bus  if self.left_axis and self.left_axis.current_state > 1 else 0.
+    def right_current(self):      return self.right_axis.motor.I_bus if self.right_axis and self.right_axis.current_state > 1 else 0.
     
     # from axis.hpp: https://github.com/madcowswe/ODrive/blob/767a2762f9b294b687d761029ef39e742bdf4539/Firmware/MotorControl/axis.hpp#L26
     MOTOR_STATES = [
diff --git a/src/odrive_ros/odrive_node.py b/src/odrive_ros/odrive_node.py
index 40ed1ad..37b6f46 100755
--- a/src/odrive_ros/odrive_node.py
+++ b/src/odrive_ros/odrive_node.py
@@ -69,7 +69,7 @@ class ODriveNode(object):
     encoder_counts_per_rev = None
     m_s_to_value = 1.0
     axis_for_right = 0
-    encoder_cpr = 4096
+    encoder_cpr = 2400
     
     # Startup parameters
     connect_on_startup = False
@@ -91,10 +91,10 @@ class ODriveNode(object):
         self.tyre_circumference = float(get_param('~tyre_circumference', 0.341)) # used to translate velocity commands in m/s into motor rpm
         
         self.connect_on_startup   = get_param('~connect_on_startup', False)
-        #self.calibrate_on_startup = get_param('~calibrate_on_startup', False)
-        #self.engage_on_startup    = get_param('~engage_on_startup', False)
+        self.calibrate_on_startup = get_param('~calibrate_on_startup', False)
+        self.engage_on_startup    = get_param('~engage_on_startup', False)
         
-        self.has_preroll     = get_param('~use_preroll', True)
+        self.has_preroll     = get_param('~use_preroll', False)
                 
         self.publish_current = get_param('~publish_current', True)
         self.publish_raw_odom =get_param('~publish_raw_odom', True)
@@ -268,7 +268,14 @@ class ODriveNode(object):
                 if not self.connect_driver(None)[0]:
                     rospy.logerr("Failed to connect.") # TODO: can we check for timeout here?
                     continue
-                    
+
+		if self.calibrate_on_startup:
+                    self.driver.calibrate()
+
+                if self.engage_on_startup:
+                    if not self.driver.engaged():
+                        self.driver.engage()
+
                 if self.publish_diagnostics:
                     self.diagnostic_updater.setHardwareID(self.driver.get_version_string())
             
@@ -371,7 +378,7 @@ class ODriveNode(object):
         if self.fast_timer_comms_active and not self.command_queue.empty():
             # check to see if we're initialised and engaged motor
             try:
-                if not self.driver.has_prerolled(): #ensure_prerolled():
+                if self.has_preroll and not self.driver.has_prerolled(): #ensure_prerolled():
                     rospy.logwarn_throttle(5.0, "ODrive has not been prerolled, ignoring drive command.")
                     motor_command = self.command_queue.get_nowait()
                     return
@@ -438,8 +445,8 @@ class ODriveNode(object):
         self.m_s_to_value = self.driver.encoder_cpr/self.tyre_circumference
         
         if self.publish_odom:
-            self.old_pos_l = self.driver.left_axis.encoder.pos_cpr
-            self.old_pos_r = self.driver.right_axis.encoder.pos_cpr
+            self.old_pos_l = self.driver.left_axis.encoder.pos_cpr_counts
+            self.old_pos_r = self.driver.right_axis.encoder.pos_cpr_counts
         
         self.fast_timer_comms_active = True
         
@@ -711,7 +718,7 @@ class ODriveNode(object):
         #rospy.loginfo("vel_l: % 2.2f  vel_r: % 2.2f  vel_l: % 2.2f  vel_r: % 2.2f  x: % 2.2f  th: % 2.2f  pos_l: % 5.1f pos_r: % 5.1f " % (
         #                vel_l, -vel_r,
         #                vel_l/encoder_cpr, vel_r/encoder_cpr, self.odom_msg.twist.twist.linear.x, self.odom_msg.twist.twist.angular.z,
-        #                self.driver.left_axis.encoder.pos_cpr, self.driver.right_axis.encoder.pos_cpr))
+        #                self.driver.left_axis.encoder.pos_cpr_counts, self.driver.right_axis.encoder.pos_cpr_counts))
         
         # Position
         delta_pos_l = self.new_pos_l - self.old_pos_l
